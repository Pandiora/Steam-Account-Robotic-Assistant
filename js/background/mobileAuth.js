// jsSha 1.6 - important version!
/////////////////////////////////

const mob = (() => {

	const getAuthKey = async(secret) => {

		const 	offset 	= await getTimeOffset(),
				epoch 	= Math.floor(Date.now() / 1000) + (offset || 0),
				time 	= leftpad(dec2hex(Math.floor(epoch / 30)), 16, 0),
				chars 	= '23456789BCDFGHJKMNPQRTVWXY';
				hmacObj = new jsSHA(time, "HEX");
				secret  = base64ToHex(secret).replace(/ /g, '');

		let code 	= '',
			fullcode= '',
			start 	= '',
			hmac 	= hmacObj.getHMAC(secret, "HEX", "SHA-1", "HEX");
			hmac 	= hexToBytes(hmac);

		// Pick the last part of the buffer and then pick 4 2-bytes
		start = hmac[19] & 0x0F;
		hmac  = hmac.slice(start, start + 4);

		// Read ArrayBuffer - Magic comes in
		fullcode = ((hmac[0] * 0x1000000) + (hmac[1] << 16) | (hmac[2] << 8) | hmac[3]) & 0x7fffffff;

		for(let i = 0; i < 5; i++) {
		  code += chars.charAt(fullcode % chars.length);
		  fullcode /= chars.length;
		}

		return code;
	};



	const getConfirmationKey = (identitySecret, time, tag) => {

		// Possible tags are: 'conf', 'details', 'allow', 'cancel'
		let buffer, hmacObj, hmac;

		/* keep old version just in case
		var dataLen = 8;
		var buffer;

		// Buffersize generated by needed action
		if(tag) {
			if(tag.length > 32) { dataLen += 32;
			} else { dataLen += tag.length; }
		}*/

		// Put everything together in a hex-string
		buffer 	= '00000000'+dec2hex(time)+strToHex(tag);
		hmacObj = new jsSHA(buffer, "HEX");
		hmac 	= hmacObj.getHMAC(identitySecret, "B64", "SHA-1", "B64");

		return hmac;
	};



	const getTimeOffset = async() =>{

		// return serverTimeOffset for !confirmation-keys!
		const startTime = Date.now(), 
			  fetchData = await fun.fetchData({
		  	delay: 0,
			options: { 
				method: 'POST',
				credentials: 'include' 
			},
			url: 'https://api.steampowered.com/ITwoFactorService/QueryTime/v1/',
			format: 'json'
		});
		
		const localTime = Date.now(), // also used as "endTime"
			  latency 	= Math.floor(((localTime - startTime) + localTime)/1000),
			  tOffset 	= fetchData.response.server_time - latency;

		return tOffset;
	};


	const generateHexString = (length) => {
		var ret = '';
		while (ret.length < length) {
			ret += Math.random().toString(16).substring(2);
		}
		return ret.substring(0, length);
	};


	const hexToBytes = (n) => {
	  for(var t = [], r = 0; r < n.length; r += 2) t.push(parseInt(n.substr(r, 2), 16));
	  return t;
	};



	const dec2hex = (n) => {
	  return (15.5 > n ? "0" : "") + Math.round(n).toString(16)
	};



	const leftpad = (n, t, r) => {
	  return t + 1 >= n.length && (n = Array(t + 1 - n.length).join(r) + n), n
	};



	const base64ToHex = (n) => {
	  for (var t = 0, r = atob(n.replace(/[ \r\n]+$/, "")), e = []; t < r.length; ++t) {
	    let o = r.charCodeAt(t).toString(16);
	    1 === o.length && (o = "0" + o), e[e.length] = o
	  }
	  return e.join(" ");
	};



	const strToHex = (str) => {
		let hex = '';
		for(let i=0;i<str.length;i++) {
			hex += ''+str.charCodeAt(i).toString(16);
		}
		return hex;
	};



	return {
		getAuthKey,
		getConfirmationKey,
		generateHexString
	}


})();

/*

SDA generates DeviceID´s (Android-Phone) randomly, so it isn´t possible
to generate the same DeviceID.

function generateDeviceId(steamID){

	var steamidhex = textToHex(steamID);
	console.log("steamID Str: "+steamID+"\nsteamID Hex: "+steamidhex);
	var sha1 = new jsSHA(steamidhex, "HEX");
	console.log(sha1);
	var replace = $(sha1).toString().replace(/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12}).*$/, '$1-$2-$3-$4-$5');

	console.log(replace);
	return "android:" + Crypto.createHash('sha1').update(steamID.toString()).digest('hex')
		.replace(/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12}).*$/, '$1-$2-$3-$4-$5');

}*/
